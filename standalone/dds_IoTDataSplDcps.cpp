#include "dds_IoTDataSplDcps.h"
#include "ccpp_dds_IoTData.h"

#include <v_copyIn.h>
#include <v_topic.h>
#include <os_stdlib.h>
#include <string.h>
#include <os_report.h>

v_copyin_result
__DDS_IoT_IoTUI8Seq__copyIn(
    c_base base,
    const ::DDS::IoT::IoTUI8Seq *from,
    _DDS_IoT_IoTUI8Seq *to)
{
    v_copyin_result result = V_COPYIN_RESULT_OK;
    (void) base;

/* Code generated by /home/dds/OvernightTests/overnight/ospli/tags/OSPL_V6_8_3-RC5/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2646 */

    static c_type type0 = NULL;
    c_type subtype0 = NULL;
    c_ulong length0;
    _DDS_IoT_IoTUI8 *dest0;

    if (type0 == NULL) {
        subtype0 = c_type(c_metaResolve (c_metaObject(base), "DDS::IoT::IoTUI8"));
        type0 = c_metaSequenceTypeNew(c_metaObject(base),"C_SEQUENCE<DDS::IoT::IoTUI8>",subtype0,0);
        c_free(subtype0);
    }
    length0 = (*from).length();
#ifdef OSPL_BOUNDS_CHECK
    dest0 = (_DDS_IoT_IoTUI8 *)c_newSequence_s(c_collectionType(type0), length0);
    if(dest0 != NULL) {
        /* Code generated by /home/dds/OvernightTests/overnight/ospli/tags/OSPL_V6_8_3-RC5/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2026 */
        const _DDS_IoT_IoTUI8 *buf0;
        buf0 = (const _DDS_IoT_IoTUI8 *)(*from).get_buffer();
        memcpy (dest0,buf0,length0* sizeof(*dest0));
        *to = (_DDS_IoT_IoTUI8Seq)dest0;
    } else {
        result = V_COPYIN_RESULT_OUT_OF_MEMORY;
    }
#else
    dest0 = (_DDS_IoT_IoTUI8 *)c_newSequence_s(c_collectionType(type0), length0);
    if(dest0 != NULL) {
        /* Code generated by /home/dds/OvernightTests/overnight/ospli/tags/OSPL_V6_8_3-RC5/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2026 */
        const _DDS_IoT_IoTUI8 *buf0;
        buf0 = (const _DDS_IoT_IoTUI8 *)(*from).get_buffer();
        memcpy (dest0,buf0,length0* sizeof(*dest0));
        *to = (_DDS_IoT_IoTUI8Seq)dest0;
    } else {
        result = V_COPYIN_RESULT_OUT_OF_MEMORY;
    }
#endif
    return result;
}

v_copyin_result
__DDS_IoT_IoTUI16Seq__copyIn(
    c_base base,
    const ::DDS::IoT::IoTUI16Seq *from,
    _DDS_IoT_IoTUI16Seq *to)
{
    v_copyin_result result = V_COPYIN_RESULT_OK;
    (void) base;

/* Code generated by /home/dds/OvernightTests/overnight/ospli/tags/OSPL_V6_8_3-RC5/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2646 */

    static c_type type0 = NULL;
    c_type subtype0 = NULL;
    c_ulong length0;
    _DDS_IoT_IoTUI16 *dest0;

    if (type0 == NULL) {
        subtype0 = c_type(c_metaResolve (c_metaObject(base), "DDS::IoT::IoTUI16"));
        type0 = c_metaSequenceTypeNew(c_metaObject(base),"C_SEQUENCE<DDS::IoT::IoTUI16>",subtype0,0);
        c_free(subtype0);
    }
    length0 = (*from).length();
#ifdef OSPL_BOUNDS_CHECK
    dest0 = (_DDS_IoT_IoTUI16 *)c_newSequence_s(c_collectionType(type0), length0);
    if(dest0 != NULL) {
        /* Code generated by /home/dds/OvernightTests/overnight/ospli/tags/OSPL_V6_8_3-RC5/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2026 */
        const _DDS_IoT_IoTUI16 *buf0;
        buf0 = (const _DDS_IoT_IoTUI16 *)(*from).get_buffer();
        memcpy (dest0,buf0,length0* sizeof(*dest0));
        *to = (_DDS_IoT_IoTUI16Seq)dest0;
    } else {
        result = V_COPYIN_RESULT_OUT_OF_MEMORY;
    }
#else
    dest0 = (_DDS_IoT_IoTUI16 *)c_newSequence_s(c_collectionType(type0), length0);
    if(dest0 != NULL) {
        /* Code generated by /home/dds/OvernightTests/overnight/ospli/tags/OSPL_V6_8_3-RC5/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2026 */
        const _DDS_IoT_IoTUI16 *buf0;
        buf0 = (const _DDS_IoT_IoTUI16 *)(*from).get_buffer();
        memcpy (dest0,buf0,length0* sizeof(*dest0));
        *to = (_DDS_IoT_IoTUI16Seq)dest0;
    } else {
        result = V_COPYIN_RESULT_OUT_OF_MEMORY;
    }
#endif
    return result;
}

v_copyin_result
__DDS_IoT_IoTUI32Seq__copyIn(
    c_base base,
    const ::DDS::IoT::IoTUI32Seq *from,
    _DDS_IoT_IoTUI32Seq *to)
{
    v_copyin_result result = V_COPYIN_RESULT_OK;
    (void) base;

/* Code generated by /home/dds/OvernightTests/overnight/ospli/tags/OSPL_V6_8_3-RC5/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2646 */

    static c_type type0 = NULL;
    c_type subtype0 = NULL;
    c_ulong length0;
    _DDS_IoT_IoTUI32 *dest0;

    if (type0 == NULL) {
        subtype0 = c_type(c_metaResolve (c_metaObject(base), "DDS::IoT::IoTUI32"));
        type0 = c_metaSequenceTypeNew(c_metaObject(base),"C_SEQUENCE<DDS::IoT::IoTUI32>",subtype0,0);
        c_free(subtype0);
    }
    length0 = (*from).length();
#ifdef OSPL_BOUNDS_CHECK
    dest0 = (_DDS_IoT_IoTUI32 *)c_newSequence_s(c_collectionType(type0), length0);
    if(dest0 != NULL) {
        /* Code generated by /home/dds/OvernightTests/overnight/ospli/tags/OSPL_V6_8_3-RC5/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2026 */
        const _DDS_IoT_IoTUI32 *buf0;
        buf0 = (const _DDS_IoT_IoTUI32 *)(*from).get_buffer();
        memcpy (dest0,buf0,length0* sizeof(*dest0));
        *to = (_DDS_IoT_IoTUI32Seq)dest0;
    } else {
        result = V_COPYIN_RESULT_OUT_OF_MEMORY;
    }
#else
    dest0 = (_DDS_IoT_IoTUI32 *)c_newSequence_s(c_collectionType(type0), length0);
    if(dest0 != NULL) {
        /* Code generated by /home/dds/OvernightTests/overnight/ospli/tags/OSPL_V6_8_3-RC5/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2026 */
        const _DDS_IoT_IoTUI32 *buf0;
        buf0 = (const _DDS_IoT_IoTUI32 *)(*from).get_buffer();
        memcpy (dest0,buf0,length0* sizeof(*dest0));
        *to = (_DDS_IoT_IoTUI32Seq)dest0;
    } else {
        result = V_COPYIN_RESULT_OUT_OF_MEMORY;
    }
#endif
    return result;
}

v_copyin_result
__DDS_IoT_IoTUI64Seq__copyIn(
    c_base base,
    const ::DDS::IoT::IoTUI64Seq *from,
    _DDS_IoT_IoTUI64Seq *to)
{
    v_copyin_result result = V_COPYIN_RESULT_OK;
    (void) base;

/* Code generated by /home/dds/OvernightTests/overnight/ospli/tags/OSPL_V6_8_3-RC5/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2646 */

    static c_type type0 = NULL;
    c_type subtype0 = NULL;
    c_ulong length0;
    _DDS_IoT_IoTUI64 *dest0;

    if (type0 == NULL) {
        subtype0 = c_type(c_metaResolve (c_metaObject(base), "DDS::IoT::IoTUI64"));
        type0 = c_metaSequenceTypeNew(c_metaObject(base),"C_SEQUENCE<DDS::IoT::IoTUI64>",subtype0,0);
        c_free(subtype0);
    }
    length0 = (*from).length();
#ifdef OSPL_BOUNDS_CHECK
    dest0 = (_DDS_IoT_IoTUI64 *)c_newSequence_s(c_collectionType(type0), length0);
    if(dest0 != NULL) {
        /* Code generated by /home/dds/OvernightTests/overnight/ospli/tags/OSPL_V6_8_3-RC5/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2026 */
        const _DDS_IoT_IoTUI64 *buf0;
        buf0 = (const _DDS_IoT_IoTUI64 *)(*from).get_buffer();
        memcpy (dest0,buf0,length0* sizeof(*dest0));
        *to = (_DDS_IoT_IoTUI64Seq)dest0;
    } else {
        result = V_COPYIN_RESULT_OUT_OF_MEMORY;
    }
#else
    dest0 = (_DDS_IoT_IoTUI64 *)c_newSequence_s(c_collectionType(type0), length0);
    if(dest0 != NULL) {
        /* Code generated by /home/dds/OvernightTests/overnight/ospli/tags/OSPL_V6_8_3-RC5/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2026 */
        const _DDS_IoT_IoTUI64 *buf0;
        buf0 = (const _DDS_IoT_IoTUI64 *)(*from).get_buffer();
        memcpy (dest0,buf0,length0* sizeof(*dest0));
        *to = (_DDS_IoT_IoTUI64Seq)dest0;
    } else {
        result = V_COPYIN_RESULT_OUT_OF_MEMORY;
    }
#endif
    return result;
}

v_copyin_result
__DDS_IoT_IoTI8Seq__copyIn(
    c_base base,
    const ::DDS::IoT::IoTI8Seq *from,
    _DDS_IoT_IoTI8Seq *to)
{
    v_copyin_result result = V_COPYIN_RESULT_OK;
    (void) base;

/* Code generated by /home/dds/OvernightTests/overnight/ospli/tags/OSPL_V6_8_3-RC5/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2646 */

    static c_type type0 = NULL;
    c_type subtype0 = NULL;
    c_ulong length0;
    _DDS_IoT_IoTI8 *dest0;

    if (type0 == NULL) {
        subtype0 = c_type(c_metaResolve (c_metaObject(base), "DDS::IoT::IoTI8"));
        type0 = c_metaSequenceTypeNew(c_metaObject(base),"C_SEQUENCE<DDS::IoT::IoTI8>",subtype0,0);
        c_free(subtype0);
    }
    length0 = (*from).length();
#ifdef OSPL_BOUNDS_CHECK
    dest0 = (_DDS_IoT_IoTI8 *)c_newSequence_s(c_collectionType(type0), length0);
    if(dest0 != NULL) {
        /* Code generated by /home/dds/OvernightTests/overnight/ospli/tags/OSPL_V6_8_3-RC5/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2026 */
        const _DDS_IoT_IoTI8 *buf0;
        buf0 = (const _DDS_IoT_IoTI8 *)(*from).get_buffer();
        memcpy (dest0,buf0,length0* sizeof(*dest0));
        *to = (_DDS_IoT_IoTI8Seq)dest0;
    } else {
        result = V_COPYIN_RESULT_OUT_OF_MEMORY;
    }
#else
    dest0 = (_DDS_IoT_IoTI8 *)c_newSequence_s(c_collectionType(type0), length0);
    if(dest0 != NULL) {
        /* Code generated by /home/dds/OvernightTests/overnight/ospli/tags/OSPL_V6_8_3-RC5/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2026 */
        const _DDS_IoT_IoTI8 *buf0;
        buf0 = (const _DDS_IoT_IoTI8 *)(*from).get_buffer();
        memcpy (dest0,buf0,length0* sizeof(*dest0));
        *to = (_DDS_IoT_IoTI8Seq)dest0;
    } else {
        result = V_COPYIN_RESULT_OUT_OF_MEMORY;
    }
#endif
    return result;
}

v_copyin_result
__DDS_IoT_IoTI16Seq__copyIn(
    c_base base,
    const ::DDS::IoT::IoTI16Seq *from,
    _DDS_IoT_IoTI16Seq *to)
{
    v_copyin_result result = V_COPYIN_RESULT_OK;
    (void) base;

/* Code generated by /home/dds/OvernightTests/overnight/ospli/tags/OSPL_V6_8_3-RC5/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2646 */

    static c_type type0 = NULL;
    c_type subtype0 = NULL;
    c_ulong length0;
    _DDS_IoT_IoTI16 *dest0;

    if (type0 == NULL) {
        subtype0 = c_type(c_metaResolve (c_metaObject(base), "DDS::IoT::IoTI16"));
        type0 = c_metaSequenceTypeNew(c_metaObject(base),"C_SEQUENCE<DDS::IoT::IoTI16>",subtype0,0);
        c_free(subtype0);
    }
    length0 = (*from).length();
#ifdef OSPL_BOUNDS_CHECK
    dest0 = (_DDS_IoT_IoTI16 *)c_newSequence_s(c_collectionType(type0), length0);
    if(dest0 != NULL) {
        /* Code generated by /home/dds/OvernightTests/overnight/ospli/tags/OSPL_V6_8_3-RC5/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2026 */
        const _DDS_IoT_IoTI16 *buf0;
        buf0 = (const _DDS_IoT_IoTI16 *)(*from).get_buffer();
        memcpy (dest0,buf0,length0* sizeof(*dest0));
        *to = (_DDS_IoT_IoTI16Seq)dest0;
    } else {
        result = V_COPYIN_RESULT_OUT_OF_MEMORY;
    }
#else
    dest0 = (_DDS_IoT_IoTI16 *)c_newSequence_s(c_collectionType(type0), length0);
    if(dest0 != NULL) {
        /* Code generated by /home/dds/OvernightTests/overnight/ospli/tags/OSPL_V6_8_3-RC5/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2026 */
        const _DDS_IoT_IoTI16 *buf0;
        buf0 = (const _DDS_IoT_IoTI16 *)(*from).get_buffer();
        memcpy (dest0,buf0,length0* sizeof(*dest0));
        *to = (_DDS_IoT_IoTI16Seq)dest0;
    } else {
        result = V_COPYIN_RESULT_OUT_OF_MEMORY;
    }
#endif
    return result;
}

v_copyin_result
__DDS_IoT_IoTI32Seq__copyIn(
    c_base base,
    const ::DDS::IoT::IoTI32Seq *from,
    _DDS_IoT_IoTI32Seq *to)
{
    v_copyin_result result = V_COPYIN_RESULT_OK;
    (void) base;

/* Code generated by /home/dds/OvernightTests/overnight/ospli/tags/OSPL_V6_8_3-RC5/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2646 */

    static c_type type0 = NULL;
    c_type subtype0 = NULL;
    c_ulong length0;
    _DDS_IoT_IoTI32 *dest0;

    if (type0 == NULL) {
        subtype0 = c_type(c_metaResolve (c_metaObject(base), "DDS::IoT::IoTI32"));
        type0 = c_metaSequenceTypeNew(c_metaObject(base),"C_SEQUENCE<DDS::IoT::IoTI32>",subtype0,0);
        c_free(subtype0);
    }
    length0 = (*from).length();
#ifdef OSPL_BOUNDS_CHECK
    dest0 = (_DDS_IoT_IoTI32 *)c_newSequence_s(c_collectionType(type0), length0);
    if(dest0 != NULL) {
        /* Code generated by /home/dds/OvernightTests/overnight/ospli/tags/OSPL_V6_8_3-RC5/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2026 */
        const _DDS_IoT_IoTI32 *buf0;
        buf0 = (const _DDS_IoT_IoTI32 *)(*from).get_buffer();
        memcpy (dest0,buf0,length0* sizeof(*dest0));
        *to = (_DDS_IoT_IoTI32Seq)dest0;
    } else {
        result = V_COPYIN_RESULT_OUT_OF_MEMORY;
    }
#else
    dest0 = (_DDS_IoT_IoTI32 *)c_newSequence_s(c_collectionType(type0), length0);
    if(dest0 != NULL) {
        /* Code generated by /home/dds/OvernightTests/overnight/ospli/tags/OSPL_V6_8_3-RC5/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2026 */
        const _DDS_IoT_IoTI32 *buf0;
        buf0 = (const _DDS_IoT_IoTI32 *)(*from).get_buffer();
        memcpy (dest0,buf0,length0* sizeof(*dest0));
        *to = (_DDS_IoT_IoTI32Seq)dest0;
    } else {
        result = V_COPYIN_RESULT_OUT_OF_MEMORY;
    }
#endif
    return result;
}

v_copyin_result
__DDS_IoT_IoTI64Seq__copyIn(
    c_base base,
    const ::DDS::IoT::IoTI64Seq *from,
    _DDS_IoT_IoTI64Seq *to)
{
    v_copyin_result result = V_COPYIN_RESULT_OK;
    (void) base;

/* Code generated by /home/dds/OvernightTests/overnight/ospli/tags/OSPL_V6_8_3-RC5/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2646 */

    static c_type type0 = NULL;
    c_type subtype0 = NULL;
    c_ulong length0;
    _DDS_IoT_IoTI64 *dest0;

    if (type0 == NULL) {
        subtype0 = c_type(c_metaResolve (c_metaObject(base), "DDS::IoT::IoTI64"));
        type0 = c_metaSequenceTypeNew(c_metaObject(base),"C_SEQUENCE<DDS::IoT::IoTI64>",subtype0,0);
        c_free(subtype0);
    }
    length0 = (*from).length();
#ifdef OSPL_BOUNDS_CHECK
    dest0 = (_DDS_IoT_IoTI64 *)c_newSequence_s(c_collectionType(type0), length0);
    if(dest0 != NULL) {
        /* Code generated by /home/dds/OvernightTests/overnight/ospli/tags/OSPL_V6_8_3-RC5/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2026 */
        const _DDS_IoT_IoTI64 *buf0;
        buf0 = (const _DDS_IoT_IoTI64 *)(*from).get_buffer();
        memcpy (dest0,buf0,length0* sizeof(*dest0));
        *to = (_DDS_IoT_IoTI64Seq)dest0;
    } else {
        result = V_COPYIN_RESULT_OUT_OF_MEMORY;
    }
#else
    dest0 = (_DDS_IoT_IoTI64 *)c_newSequence_s(c_collectionType(type0), length0);
    if(dest0 != NULL) {
        /* Code generated by /home/dds/OvernightTests/overnight/ospli/tags/OSPL_V6_8_3-RC5/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2026 */
        const _DDS_IoT_IoTI64 *buf0;
        buf0 = (const _DDS_IoT_IoTI64 *)(*from).get_buffer();
        memcpy (dest0,buf0,length0* sizeof(*dest0));
        *to = (_DDS_IoT_IoTI64Seq)dest0;
    } else {
        result = V_COPYIN_RESULT_OUT_OF_MEMORY;
    }
#endif
    return result;
}

v_copyin_result
__DDS_IoT_IoTF32Seq__copyIn(
    c_base base,
    const ::DDS::IoT::IoTF32Seq *from,
    _DDS_IoT_IoTF32Seq *to)
{
    v_copyin_result result = V_COPYIN_RESULT_OK;
    (void) base;

/* Code generated by /home/dds/OvernightTests/overnight/ospli/tags/OSPL_V6_8_3-RC5/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2646 */

    static c_type type0 = NULL;
    c_type subtype0 = NULL;
    c_ulong length0;
    _DDS_IoT_IoTF32 *dest0;

    if (type0 == NULL) {
        subtype0 = c_type(c_metaResolve (c_metaObject(base), "DDS::IoT::IoTF32"));
        type0 = c_metaSequenceTypeNew(c_metaObject(base),"C_SEQUENCE<DDS::IoT::IoTF32>",subtype0,0);
        c_free(subtype0);
    }
    length0 = (*from).length();
#ifdef OSPL_BOUNDS_CHECK
    dest0 = (_DDS_IoT_IoTF32 *)c_newSequence_s(c_collectionType(type0), length0);
    if(dest0 != NULL) {
        /* Code generated by /home/dds/OvernightTests/overnight/ospli/tags/OSPL_V6_8_3-RC5/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2026 */
        const _DDS_IoT_IoTF32 *buf0;
        buf0 = (const _DDS_IoT_IoTF32 *)(*from).get_buffer();
        memcpy (dest0,buf0,length0* sizeof(*dest0));
        *to = (_DDS_IoT_IoTF32Seq)dest0;
    } else {
        result = V_COPYIN_RESULT_OUT_OF_MEMORY;
    }
#else
    dest0 = (_DDS_IoT_IoTF32 *)c_newSequence_s(c_collectionType(type0), length0);
    if(dest0 != NULL) {
        /* Code generated by /home/dds/OvernightTests/overnight/ospli/tags/OSPL_V6_8_3-RC5/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2026 */
        const _DDS_IoT_IoTF32 *buf0;
        buf0 = (const _DDS_IoT_IoTF32 *)(*from).get_buffer();
        memcpy (dest0,buf0,length0* sizeof(*dest0));
        *to = (_DDS_IoT_IoTF32Seq)dest0;
    } else {
        result = V_COPYIN_RESULT_OUT_OF_MEMORY;
    }
#endif
    return result;
}

v_copyin_result
__DDS_IoT_IoTF64Seq__copyIn(
    c_base base,
    const ::DDS::IoT::IoTF64Seq *from,
    _DDS_IoT_IoTF64Seq *to)
{
    v_copyin_result result = V_COPYIN_RESULT_OK;
    (void) base;

/* Code generated by /home/dds/OvernightTests/overnight/ospli/tags/OSPL_V6_8_3-RC5/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2646 */

    static c_type type0 = NULL;
    c_type subtype0 = NULL;
    c_ulong length0;
    _DDS_IoT_IoTF64 *dest0;

    if (type0 == NULL) {
        subtype0 = c_type(c_metaResolve (c_metaObject(base), "DDS::IoT::IoTF64"));
        type0 = c_metaSequenceTypeNew(c_metaObject(base),"C_SEQUENCE<DDS::IoT::IoTF64>",subtype0,0);
        c_free(subtype0);
    }
    length0 = (*from).length();
#ifdef OSPL_BOUNDS_CHECK
    dest0 = (_DDS_IoT_IoTF64 *)c_newSequence_s(c_collectionType(type0), length0);
    if(dest0 != NULL) {
        /* Code generated by /home/dds/OvernightTests/overnight/ospli/tags/OSPL_V6_8_3-RC5/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2026 */
        const _DDS_IoT_IoTF64 *buf0;
        buf0 = (const _DDS_IoT_IoTF64 *)(*from).get_buffer();
        memcpy (dest0,buf0,length0* sizeof(*dest0));
        *to = (_DDS_IoT_IoTF64Seq)dest0;
    } else {
        result = V_COPYIN_RESULT_OUT_OF_MEMORY;
    }
#else
    dest0 = (_DDS_IoT_IoTF64 *)c_newSequence_s(c_collectionType(type0), length0);
    if(dest0 != NULL) {
        /* Code generated by /home/dds/OvernightTests/overnight/ospli/tags/OSPL_V6_8_3-RC5/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2026 */
        const _DDS_IoT_IoTF64 *buf0;
        buf0 = (const _DDS_IoT_IoTF64 *)(*from).get_buffer();
        memcpy (dest0,buf0,length0* sizeof(*dest0));
        *to = (_DDS_IoT_IoTF64Seq)dest0;
    } else {
        result = V_COPYIN_RESULT_OUT_OF_MEMORY;
    }
#endif
    return result;
}

v_copyin_result
__DDS_IoT_IoTBSeq__copyIn(
    c_base base,
    const ::DDS::IoT::IoTBSeq *from,
    _DDS_IoT_IoTBSeq *to)
{
    v_copyin_result result = V_COPYIN_RESULT_OK;
    (void) base;

/* Code generated by /home/dds/OvernightTests/overnight/ospli/tags/OSPL_V6_8_3-RC5/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2646 */

    static c_type type0 = NULL;
    c_type subtype0 = NULL;
    c_ulong length0;
    _DDS_IoT_IoTB *dest0;

    if (type0 == NULL) {
        subtype0 = c_type(c_metaResolve (c_metaObject(base), "DDS::IoT::IoTB"));
        type0 = c_metaSequenceTypeNew(c_metaObject(base),"C_SEQUENCE<DDS::IoT::IoTB>",subtype0,0);
        c_free(subtype0);
    }
    length0 = (*from).length();
#ifdef OSPL_BOUNDS_CHECK
    dest0 = (_DDS_IoT_IoTB *)c_newSequence_s(c_collectionType(type0), length0);
    if(dest0 != NULL) {
        /* Code generated by /home/dds/OvernightTests/overnight/ospli/tags/OSPL_V6_8_3-RC5/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2026 */
        const _DDS_IoT_IoTB *buf0;
        buf0 = (const _DDS_IoT_IoTB *)(*from).get_buffer();
        memcpy (dest0,buf0,length0* sizeof(*dest0));
        *to = (_DDS_IoT_IoTBSeq)dest0;
    } else {
        result = V_COPYIN_RESULT_OUT_OF_MEMORY;
    }
#else
    dest0 = (_DDS_IoT_IoTB *)c_newSequence_s(c_collectionType(type0), length0);
    if(dest0 != NULL) {
        /* Code generated by /home/dds/OvernightTests/overnight/ospli/tags/OSPL_V6_8_3-RC5/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2026 */
        const _DDS_IoT_IoTB *buf0;
        buf0 = (const _DDS_IoT_IoTB *)(*from).get_buffer();
        memcpy (dest0,buf0,length0* sizeof(*dest0));
        *to = (_DDS_IoT_IoTBSeq)dest0;
    } else {
        result = V_COPYIN_RESULT_OUT_OF_MEMORY;
    }
#endif
    return result;
}

v_copyin_result
__DDS_IoT_IoTStrSeq__copyIn(
    c_base base,
    const ::DDS::IoT::IoTStrSeq *from,
    _DDS_IoT_IoTStrSeq *to)
{
    v_copyin_result result = V_COPYIN_RESULT_OK;
    (void) base;

/* Code generated by /home/dds/OvernightTests/overnight/ospli/tags/OSPL_V6_8_3-RC5/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2646 */

    static c_type type0 = NULL;
    c_type subtype0 = NULL;
    c_ulong length0;
    _DDS_IoT_IoTStr *dest0;

    if (type0 == NULL) {
        subtype0 = c_type(c_metaResolve (c_metaObject(base), "DDS::IoT::IoTStr"));
        type0 = c_metaSequenceTypeNew(c_metaObject(base),"C_SEQUENCE<DDS::IoT::IoTStr>",subtype0,0);
        c_free(subtype0);
    }
    length0 = (*from).length();
#ifdef OSPL_BOUNDS_CHECK
    dest0 = (_DDS_IoT_IoTStr *)c_newSequence_s(c_collectionType(type0), length0);
    if(dest0 != NULL) {
        /* Code generated by /home/dds/OvernightTests/overnight/ospli/tags/OSPL_V6_8_3-RC5/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2081 */
        unsigned int i0;
        for (i0 = 0; (i0 < length0) && V_COPYIN_RESULT_IS_OK(result); i0++) {
    
#ifdef OSPL_BOUNDS_CHECK
            if((*from)[i0]){
                dest0[i0] = c_stringNew_s(base, (*from)[i0]);
                if(dest0[i0] == NULL) {
                    result = V_COPYIN_RESULT_OUT_OF_MEMORY;
                }
            } else {
                OS_REPORT (OS_ERROR, "copyIn", 0,"Element of 'DDS::IoT.*from' of type 'IoTStr' is NULL.");
                result = V_COPYIN_RESULT_INVALID;
            }
#else
            dest0[i0] = c_stringNew_s(base, (*from)[i0]);
            if(dest0[i0] == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
        }
        *to = (_DDS_IoT_IoTStrSeq)dest0;
    } else {
        result = V_COPYIN_RESULT_OUT_OF_MEMORY;
    }
#else
    dest0 = (_DDS_IoT_IoTStr *)c_newSequence_s(c_collectionType(type0), length0);
    if(dest0 != NULL) {
        /* Code generated by /home/dds/OvernightTests/overnight/ospli/tags/OSPL_V6_8_3-RC5/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2081 */
        unsigned int i0;
        for (i0 = 0; (i0 < length0) && V_COPYIN_RESULT_IS_OK(result); i0++) {
    
#ifdef OSPL_BOUNDS_CHECK
            if((*from)[i0]){
                dest0[i0] = c_stringNew_s(base, (*from)[i0]);
                if(dest0[i0] == NULL) {
                    result = V_COPYIN_RESULT_OUT_OF_MEMORY;
                }
            } else {
                OS_REPORT (OS_ERROR, "copyIn", 0,"Element of 'DDS::IoT.*from' of type 'IoTStr' is NULL.");
                result = V_COPYIN_RESULT_INVALID;
            }
#else
            dest0[i0] = c_stringNew_s(base, (*from)[i0]);
            if(dest0[i0] == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
        }
        *to = (_DDS_IoT_IoTStrSeq)dest0;
    } else {
        result = V_COPYIN_RESULT_OUT_OF_MEMORY;
    }
#endif
    return result;
}

v_copyin_result
__DDS_IoT_IoTChSeq__copyIn(
    c_base base,
    const ::DDS::IoT::IoTChSeq *from,
    _DDS_IoT_IoTChSeq *to)
{
    v_copyin_result result = V_COPYIN_RESULT_OK;
    (void) base;

/* Code generated by /home/dds/OvernightTests/overnight/ospli/tags/OSPL_V6_8_3-RC5/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2646 */

    static c_type type0 = NULL;
    c_type subtype0 = NULL;
    c_ulong length0;
    _DDS_IoT_IoTCh *dest0;

    if (type0 == NULL) {
        subtype0 = c_type(c_metaResolve (c_metaObject(base), "DDS::IoT::IoTCh"));
        type0 = c_metaSequenceTypeNew(c_metaObject(base),"C_SEQUENCE<DDS::IoT::IoTCh>",subtype0,0);
        c_free(subtype0);
    }
    length0 = (*from).length();
#ifdef OSPL_BOUNDS_CHECK
    dest0 = (_DDS_IoT_IoTCh *)c_newSequence_s(c_collectionType(type0), length0);
    if(dest0 != NULL) {
        /* Code generated by /home/dds/OvernightTests/overnight/ospli/tags/OSPL_V6_8_3-RC5/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2026 */
        const _DDS_IoT_IoTCh *buf0;
        buf0 = (const _DDS_IoT_IoTCh *)(*from).get_buffer();
        memcpy (dest0,buf0,length0* sizeof(*dest0));
        *to = (_DDS_IoT_IoTChSeq)dest0;
    } else {
        result = V_COPYIN_RESULT_OUT_OF_MEMORY;
    }
#else
    dest0 = (_DDS_IoT_IoTCh *)c_newSequence_s(c_collectionType(type0), length0);
    if(dest0 != NULL) {
        /* Code generated by /home/dds/OvernightTests/overnight/ospli/tags/OSPL_V6_8_3-RC5/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2026 */
        const _DDS_IoT_IoTCh *buf0;
        buf0 = (const _DDS_IoT_IoTCh *)(*from).get_buffer();
        memcpy (dest0,buf0,length0* sizeof(*dest0));
        *to = (_DDS_IoT_IoTChSeq)dest0;
    } else {
        result = V_COPYIN_RESULT_OUT_OF_MEMORY;
    }
#endif
    return result;
}

v_copyin_result
__DDS_IoT_IoTValue__copyIn(
    c_base base,
    const ::DDS::IoT::IoTValue *from,
    struct _DDS_IoT_IoTValue *to)
{
    v_copyin_result result = V_COPYIN_RESULT_OK;
    (void) base;

#ifdef OSPL_BOUNDS_CHECK
    if((((c_long)(from->_d())) >= 0) && (((c_long)(from->_d())) < 26)){
        to->_d = (enum _DDS_IoT_IoTType)from->_d();
    } else {
        OS_REPORT (OS_ERROR, "copyIn", 0,"Element of 'DDS::IoT.IoTValue' of type 'IoTValue' is out of range.");
        result = V_COPYIN_RESULT_INVALID;
    }
#else
    to->_d = (enum _DDS_IoT_IoTType)from->_d();
#endif
    switch (to->_d) {
    case _DDS_IoT_TYPE_IoTUI8:
        to->_u.ui8 = (c_octet)from->ui8();
        break;
    case _DDS_IoT_TYPE_IoTUI16:
        to->_u.ui16 = (c_ushort)from->ui16();
        break;
    case _DDS_IoT_TYPE_IoTUI32:
        to->_u.ui32 = (c_ulong)from->ui32();
        break;
    case _DDS_IoT_TYPE_IoTUI64:
        to->_u.ui64 = (c_ulonglong)from->ui64();
        break;
    case _DDS_IoT_TYPE_IoTI8:
        to->_u.i8 = (c_char)from->i8();
        break;
    case _DDS_IoT_TYPE_IoTI16:
        to->_u.i16 = (c_short)from->i16();
        break;
    case _DDS_IoT_TYPE_IoTI32:
        to->_u.i32 = (c_long)from->i32();
        break;
    case _DDS_IoT_TYPE_IoTI64:
        to->_u.i64 = (c_longlong)from->i64();
        break;
    case _DDS_IoT_TYPE_IoTF32:
        to->_u.f32 = (c_float)from->f32();
        break;
    case _DDS_IoT_TYPE_IoTF64:
        to->_u.f64 = (c_double)from->f64();
        break;
    case _DDS_IoT_TYPE_IoTB:
        to->_u.b = (c_bool)from->b();
        break;
    case _DDS_IoT_TYPE_IoTStr:
#ifdef OSPL_BOUNDS_CHECK
        if(from->str()){
        to->_u.str = c_stringNew_s(base, from->str());
             if(to->_u.str == NULL) {
                 result = V_COPYIN_RESULT_OUT_OF_MEMORY;
             }
        } else {
            OS_REPORT (OS_ERROR, "copyIn", 0,"Case 'DDS::IoT::IoTValue.str' of type 'c_string' is NULL.");
            result = V_COPYIN_RESULT_INVALID;
        }
#else
    to->_u.str = c_stringNew_s(base, from->str());
     if(to->_u.str == NULL) {
         result = V_COPYIN_RESULT_OUT_OF_MEMORY;
     }
#endif
        break;
    case _DDS_IoT_TYPE_IoTCh:
        to->_u.ch = (c_char)from->ch();
        break;
    case _DDS_IoT_TYPE_IoTUI8Seq:
        if(V_COPYIN_RESULT_IS_OK(result)){
            extern v_copyin_result __DDS_IoT_IoTUI8Seq__copyIn(c_base, const ::DDS::IoT::IoTUI8Seq *, _DDS_IoT_IoTUI8Seq *);
            const ::DDS::IoT::IoTUI8Seq &x = from->ui8Seq();
            result = __DDS_IoT_IoTUI8Seq__copyIn(base, &x, &to->_u.ui8Seq);
        }
        break;
    case _DDS_IoT_TYPE_IoTUI16Seq:
        if(V_COPYIN_RESULT_IS_OK(result)){
            extern v_copyin_result __DDS_IoT_IoTUI16Seq__copyIn(c_base, const ::DDS::IoT::IoTUI16Seq *, _DDS_IoT_IoTUI16Seq *);
            const ::DDS::IoT::IoTUI16Seq &x = from->ui16Seq();
            result = __DDS_IoT_IoTUI16Seq__copyIn(base, &x, &to->_u.ui16Seq);
        }
        break;
    case _DDS_IoT_TYPE_IoTUI32Seq:
        if(V_COPYIN_RESULT_IS_OK(result)){
            extern v_copyin_result __DDS_IoT_IoTUI32Seq__copyIn(c_base, const ::DDS::IoT::IoTUI32Seq *, _DDS_IoT_IoTUI32Seq *);
            const ::DDS::IoT::IoTUI32Seq &x = from->ui32Seq();
            result = __DDS_IoT_IoTUI32Seq__copyIn(base, &x, &to->_u.ui32Seq);
        }
        break;
    case _DDS_IoT_TYPE_IoTUI64Seq:
        if(V_COPYIN_RESULT_IS_OK(result)){
            extern v_copyin_result __DDS_IoT_IoTUI64Seq__copyIn(c_base, const ::DDS::IoT::IoTUI64Seq *, _DDS_IoT_IoTUI64Seq *);
            const ::DDS::IoT::IoTUI64Seq &x = from->ui64Seq();
            result = __DDS_IoT_IoTUI64Seq__copyIn(base, &x, &to->_u.ui64Seq);
        }
        break;
    case _DDS_IoT_TYPE_IoTI8Seq:
        if(V_COPYIN_RESULT_IS_OK(result)){
            extern v_copyin_result __DDS_IoT_IoTI8Seq__copyIn(c_base, const ::DDS::IoT::IoTI8Seq *, _DDS_IoT_IoTI8Seq *);
            const ::DDS::IoT::IoTI8Seq &x = from->i8Seq();
            result = __DDS_IoT_IoTI8Seq__copyIn(base, &x, &to->_u.i8Seq);
        }
        break;
    case _DDS_IoT_TYPE_IoTI16Seq:
        if(V_COPYIN_RESULT_IS_OK(result)){
            extern v_copyin_result __DDS_IoT_IoTI16Seq__copyIn(c_base, const ::DDS::IoT::IoTI16Seq *, _DDS_IoT_IoTI16Seq *);
            const ::DDS::IoT::IoTI16Seq &x = from->i16Seq();
            result = __DDS_IoT_IoTI16Seq__copyIn(base, &x, &to->_u.i16Seq);
        }
        break;
    case _DDS_IoT_TYPE_IoTI32Seq:
        if(V_COPYIN_RESULT_IS_OK(result)){
            extern v_copyin_result __DDS_IoT_IoTI32Seq__copyIn(c_base, const ::DDS::IoT::IoTI32Seq *, _DDS_IoT_IoTI32Seq *);
            const ::DDS::IoT::IoTI32Seq &x = from->i32Seq();
            result = __DDS_IoT_IoTI32Seq__copyIn(base, &x, &to->_u.i32Seq);
        }
        break;
    case _DDS_IoT_TYPE_IoTI64Seq:
        if(V_COPYIN_RESULT_IS_OK(result)){
            extern v_copyin_result __DDS_IoT_IoTI64Seq__copyIn(c_base, const ::DDS::IoT::IoTI64Seq *, _DDS_IoT_IoTI64Seq *);
            const ::DDS::IoT::IoTI64Seq &x = from->i64Seq();
            result = __DDS_IoT_IoTI64Seq__copyIn(base, &x, &to->_u.i64Seq);
        }
        break;
    case _DDS_IoT_TYPE_IoTF32Seq:
        if(V_COPYIN_RESULT_IS_OK(result)){
            extern v_copyin_result __DDS_IoT_IoTF32Seq__copyIn(c_base, const ::DDS::IoT::IoTF32Seq *, _DDS_IoT_IoTF32Seq *);
            const ::DDS::IoT::IoTF32Seq &x = from->f32Seq();
            result = __DDS_IoT_IoTF32Seq__copyIn(base, &x, &to->_u.f32Seq);
        }
        break;
    case _DDS_IoT_TYPE_IoTF64Seq:
        if(V_COPYIN_RESULT_IS_OK(result)){
            extern v_copyin_result __DDS_IoT_IoTF64Seq__copyIn(c_base, const ::DDS::IoT::IoTF64Seq *, _DDS_IoT_IoTF64Seq *);
            const ::DDS::IoT::IoTF64Seq &x = from->f64Seq();
            result = __DDS_IoT_IoTF64Seq__copyIn(base, &x, &to->_u.f64Seq);
        }
        break;
    case _DDS_IoT_TYPE_IoTBSeq:
        if(V_COPYIN_RESULT_IS_OK(result)){
            extern v_copyin_result __DDS_IoT_IoTBSeq__copyIn(c_base, const ::DDS::IoT::IoTBSeq *, _DDS_IoT_IoTBSeq *);
            const ::DDS::IoT::IoTBSeq &x = from->bSeq();
            result = __DDS_IoT_IoTBSeq__copyIn(base, &x, &to->_u.bSeq);
        }
        break;
    case _DDS_IoT_TYPE_IoTStrSeq:
        if(V_COPYIN_RESULT_IS_OK(result)){
            extern v_copyin_result __DDS_IoT_IoTStrSeq__copyIn(c_base, const ::DDS::IoT::IoTStrSeq *, _DDS_IoT_IoTStrSeq *);
            const ::DDS::IoT::IoTStrSeq &x = from->strSeq();
            result = __DDS_IoT_IoTStrSeq__copyIn(base, &x, &to->_u.strSeq);
        }
        break;
    case _DDS_IoT_TYPE_IoTChSeq:
        if(V_COPYIN_RESULT_IS_OK(result)){
            extern v_copyin_result __DDS_IoT_IoTChSeq__copyIn(c_base, const ::DDS::IoT::IoTChSeq *, _DDS_IoT_IoTChSeq *);
            const ::DDS::IoT::IoTChSeq &x = from->chSeq();
            result = __DDS_IoT_IoTChSeq__copyIn(base, &x, &to->_u.chSeq);
        }
        break;
    }
    return result;
}

v_copyin_result
__DDS_IoT_IoTNVP__copyIn(
    c_base base,
    const struct ::DDS::IoT::IoTNVP *from,
    struct _DDS_IoT_IoTNVP *to)
{
    v_copyin_result result = V_COPYIN_RESULT_OK;
    (void) base;

#ifdef OSPL_BOUNDS_CHECK
    if(from->name){
        to->name = c_stringNew_s(base, from->name);
        if(to->name == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
    } else {
        OS_REPORT (OS_ERROR, "copyIn", 0,"Member 'DDS::IoT::IoTNVP.name' of type 'c_string' is NULL.");
        result = V_COPYIN_RESULT_INVALID;
    }
#else
    to->name = c_stringNew_s(base, from->name);
    if(to->name == NULL) {
        result = V_COPYIN_RESULT_OUT_OF_MEMORY;
    }
#endif
    if(V_COPYIN_RESULT_IS_OK(result)){
        extern v_copyin_result __DDS_IoT_IoTValue__copyIn(c_base, const ::DDS::IoT::IoTValue *, _DDS_IoT_IoTValue *);
        result = __DDS_IoT_IoTValue__copyIn(base, &from->value, &to->value);
    }
    return result;
}

v_copyin_result
__DDS_IoT_IoTNVPSeq__copyIn(
    c_base base,
    const ::DDS::IoT::IoTNVPSeq *from,
    _DDS_IoT_IoTNVPSeq *to)
{
    v_copyin_result result = V_COPYIN_RESULT_OK;
    (void) base;

/* Code generated by /home/dds/OvernightTests/overnight/ospli/tags/OSPL_V6_8_3-RC5/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2646 */

    static c_type type0 = NULL;
    c_type subtype0 = NULL;
    c_ulong length0;
    struct _DDS_IoT_IoTNVP *dest0;

    if (type0 == NULL) {
        subtype0 = c_type(c_metaResolve (c_metaObject(base), "DDS::IoT::IoTNVP"));
        type0 = c_metaSequenceTypeNew(c_metaObject(base),"C_SEQUENCE<DDS::IoT::IoTNVP>",subtype0,0);
        c_free(subtype0);
    }
    length0 = (*from).length();
#ifdef OSPL_BOUNDS_CHECK
    dest0 = (struct _DDS_IoT_IoTNVP *)c_newSequence_s(c_collectionType(type0), length0);
    if(dest0 != NULL) {
        /* Code generated by /home/dds/OvernightTests/overnight/ospli/tags/OSPL_V6_8_3-RC5/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2081 */
        unsigned int i0;
        for (i0 = 0; (i0 < length0) && V_COPYIN_RESULT_IS_OK(result); i0++) {
            extern v_copyin_result __DDS_IoT_IoTNVP__copyIn(c_base base,
                const DDS::IoT::IoTNVP *From,
                struct _DDS_IoT_IoTNVP *To);

            result = __DDS_IoT_IoTNVP__copyIn(base, &(*from)[i0], (struct _DDS_IoT_IoTNVP *)&dest0[i0]);
        }
        *to = (_DDS_IoT_IoTNVPSeq)dest0;
    } else {
        result = V_COPYIN_RESULT_OUT_OF_MEMORY;
    }
#else
    dest0 = (struct _DDS_IoT_IoTNVP *)c_newSequence_s(c_collectionType(type0), length0);
    if(dest0 != NULL) {
        /* Code generated by /home/dds/OvernightTests/overnight/ospli/tags/OSPL_V6_8_3-RC5/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2081 */
        unsigned int i0;
        for (i0 = 0; (i0 < length0) && V_COPYIN_RESULT_IS_OK(result); i0++) {
            extern v_copyin_result __DDS_IoT_IoTNVP__copyIn(c_base base,
                const DDS::IoT::IoTNVP *From,
                struct _DDS_IoT_IoTNVP *To);

            result = __DDS_IoT_IoTNVP__copyIn(base, &(*from)[i0], (struct _DDS_IoT_IoTNVP *)&dest0[i0]);
        }
        *to = (_DDS_IoT_IoTNVPSeq)dest0;
    } else {
        result = V_COPYIN_RESULT_OUT_OF_MEMORY;
    }
#endif
    return result;
}

v_copyin_result
__DDS_IoT_IoTData__copyIn(
    c_base base,
    const struct ::DDS::IoT::IoTData *from,
    struct _DDS_IoT_IoTData *to)
{
    v_copyin_result result = V_COPYIN_RESULT_OK;
    (void) base;

#ifdef OSPL_BOUNDS_CHECK
    if(from->typeName){
        to->typeName = c_stringNew_s(base, from->typeName);
        if(to->typeName == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
    } else {
        OS_REPORT (OS_ERROR, "copyIn", 0,"Member 'DDS::IoT::IoTData.typeName' of type 'c_string' is NULL.");
        result = V_COPYIN_RESULT_INVALID;
    }
#else
    to->typeName = c_stringNew_s(base, from->typeName);
    if(to->typeName == NULL) {
        result = V_COPYIN_RESULT_OUT_OF_MEMORY;
    }
#endif
#ifdef OSPL_BOUNDS_CHECK
    if(from->instanceId){
        to->instanceId = c_stringNew_s(base, from->instanceId);
        if(to->instanceId == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
    } else {
        OS_REPORT (OS_ERROR, "copyIn", 0,"Member 'DDS::IoT::IoTData.instanceId' of type 'c_string' is NULL.");
        result = V_COPYIN_RESULT_INVALID;
    }
#else
    to->instanceId = c_stringNew_s(base, from->instanceId);
    if(to->instanceId == NULL) {
        result = V_COPYIN_RESULT_OUT_OF_MEMORY;
    }
#endif
    if(V_COPYIN_RESULT_IS_OK(result)){
        extern v_copyin_result __DDS_IoT_IoTNVPSeq__copyIn(c_base, const ::DDS::IoT::IoTNVPSeq *, _DDS_IoT_IoTNVPSeq *);
        result = __DDS_IoT_IoTNVPSeq__copyIn(base, &from->values, &to->values);
    }
    return result;
}

void
__DDS_IoT_IoTUI8Seq__copyOut(
    const void *_from,
    void *_to)
{
    const _DDS_IoT_IoTUI8Seq *from = (const _DDS_IoT_IoTUI8Seq *)_from;
    ::DDS::IoT::IoTUI8Seq *to = (::DDS::IoT::IoTUI8Seq *)_to;
    long size0;
    const _DDS_IoT_IoTUI8 *src0 = (const _DDS_IoT_IoTUI8 *)(*from);

    size0 = c_arraySize(c_sequence(src0));
    (*to).length(size0);
    {
        _DDS_IoT_IoTUI8 *buf0;
        buf0 = (_DDS_IoT_IoTUI8 *)(*to).get_buffer();
        memcpy ((void *)buf0,src0,size0* sizeof(*buf0));
    }
}

void
__DDS_IoT_IoTUI16Seq__copyOut(
    const void *_from,
    void *_to)
{
    const _DDS_IoT_IoTUI16Seq *from = (const _DDS_IoT_IoTUI16Seq *)_from;
    ::DDS::IoT::IoTUI16Seq *to = (::DDS::IoT::IoTUI16Seq *)_to;
    long size0;
    const _DDS_IoT_IoTUI16 *src0 = (const _DDS_IoT_IoTUI16 *)(*from);

    size0 = c_arraySize(c_sequence(src0));
    (*to).length(size0);
    {
        _DDS_IoT_IoTUI16 *buf0;
        buf0 = (_DDS_IoT_IoTUI16 *)(*to).get_buffer();
        memcpy ((void *)buf0,src0,size0* sizeof(*buf0));
    }
}

void
__DDS_IoT_IoTUI32Seq__copyOut(
    const void *_from,
    void *_to)
{
    const _DDS_IoT_IoTUI32Seq *from = (const _DDS_IoT_IoTUI32Seq *)_from;
    ::DDS::IoT::IoTUI32Seq *to = (::DDS::IoT::IoTUI32Seq *)_to;
    long size0;
    const _DDS_IoT_IoTUI32 *src0 = (const _DDS_IoT_IoTUI32 *)(*from);

    size0 = c_arraySize(c_sequence(src0));
    (*to).length(size0);
    {
        _DDS_IoT_IoTUI32 *buf0;
        buf0 = (_DDS_IoT_IoTUI32 *)(*to).get_buffer();
        memcpy ((void *)buf0,src0,size0* sizeof(*buf0));
    }
}

void
__DDS_IoT_IoTUI64Seq__copyOut(
    const void *_from,
    void *_to)
{
    const _DDS_IoT_IoTUI64Seq *from = (const _DDS_IoT_IoTUI64Seq *)_from;
    ::DDS::IoT::IoTUI64Seq *to = (::DDS::IoT::IoTUI64Seq *)_to;
    long size0;
    const _DDS_IoT_IoTUI64 *src0 = (const _DDS_IoT_IoTUI64 *)(*from);

    size0 = c_arraySize(c_sequence(src0));
    (*to).length(size0);
    {
        _DDS_IoT_IoTUI64 *buf0;
        buf0 = (_DDS_IoT_IoTUI64 *)(*to).get_buffer();
        memcpy ((void *)buf0,src0,size0* sizeof(*buf0));
    }
}

void
__DDS_IoT_IoTI8Seq__copyOut(
    const void *_from,
    void *_to)
{
    const _DDS_IoT_IoTI8Seq *from = (const _DDS_IoT_IoTI8Seq *)_from;
    ::DDS::IoT::IoTI8Seq *to = (::DDS::IoT::IoTI8Seq *)_to;
    long size0;
    const _DDS_IoT_IoTI8 *src0 = (const _DDS_IoT_IoTI8 *)(*from);

    size0 = c_arraySize(c_sequence(src0));
    (*to).length(size0);
    {
        _DDS_IoT_IoTI8 *buf0;
        buf0 = (_DDS_IoT_IoTI8 *)(*to).get_buffer();
        memcpy ((void *)buf0,src0,size0* sizeof(*buf0));
    }
}

void
__DDS_IoT_IoTI16Seq__copyOut(
    const void *_from,
    void *_to)
{
    const _DDS_IoT_IoTI16Seq *from = (const _DDS_IoT_IoTI16Seq *)_from;
    ::DDS::IoT::IoTI16Seq *to = (::DDS::IoT::IoTI16Seq *)_to;
    long size0;
    const _DDS_IoT_IoTI16 *src0 = (const _DDS_IoT_IoTI16 *)(*from);

    size0 = c_arraySize(c_sequence(src0));
    (*to).length(size0);
    {
        _DDS_IoT_IoTI16 *buf0;
        buf0 = (_DDS_IoT_IoTI16 *)(*to).get_buffer();
        memcpy ((void *)buf0,src0,size0* sizeof(*buf0));
    }
}

void
__DDS_IoT_IoTI32Seq__copyOut(
    const void *_from,
    void *_to)
{
    const _DDS_IoT_IoTI32Seq *from = (const _DDS_IoT_IoTI32Seq *)_from;
    ::DDS::IoT::IoTI32Seq *to = (::DDS::IoT::IoTI32Seq *)_to;
    long size0;
    const _DDS_IoT_IoTI32 *src0 = (const _DDS_IoT_IoTI32 *)(*from);

    size0 = c_arraySize(c_sequence(src0));
    (*to).length(size0);
    {
        _DDS_IoT_IoTI32 *buf0;
        buf0 = (_DDS_IoT_IoTI32 *)(*to).get_buffer();
        memcpy ((void *)buf0,src0,size0* sizeof(*buf0));
    }
}

void
__DDS_IoT_IoTI64Seq__copyOut(
    const void *_from,
    void *_to)
{
    const _DDS_IoT_IoTI64Seq *from = (const _DDS_IoT_IoTI64Seq *)_from;
    ::DDS::IoT::IoTI64Seq *to = (::DDS::IoT::IoTI64Seq *)_to;
    long size0;
    const _DDS_IoT_IoTI64 *src0 = (const _DDS_IoT_IoTI64 *)(*from);

    size0 = c_arraySize(c_sequence(src0));
    (*to).length(size0);
    {
        _DDS_IoT_IoTI64 *buf0;
        buf0 = (_DDS_IoT_IoTI64 *)(*to).get_buffer();
        memcpy ((void *)buf0,src0,size0* sizeof(*buf0));
    }
}

void
__DDS_IoT_IoTF32Seq__copyOut(
    const void *_from,
    void *_to)
{
    const _DDS_IoT_IoTF32Seq *from = (const _DDS_IoT_IoTF32Seq *)_from;
    ::DDS::IoT::IoTF32Seq *to = (::DDS::IoT::IoTF32Seq *)_to;
    long size0;
    const _DDS_IoT_IoTF32 *src0 = (const _DDS_IoT_IoTF32 *)(*from);

    size0 = c_arraySize(c_sequence(src0));
    (*to).length(size0);
    {
        _DDS_IoT_IoTF32 *buf0;
        buf0 = (_DDS_IoT_IoTF32 *)(*to).get_buffer();
        memcpy ((void *)buf0,src0,size0* sizeof(*buf0));
    }
}

void
__DDS_IoT_IoTF64Seq__copyOut(
    const void *_from,
    void *_to)
{
    const _DDS_IoT_IoTF64Seq *from = (const _DDS_IoT_IoTF64Seq *)_from;
    ::DDS::IoT::IoTF64Seq *to = (::DDS::IoT::IoTF64Seq *)_to;
    long size0;
    const _DDS_IoT_IoTF64 *src0 = (const _DDS_IoT_IoTF64 *)(*from);

    size0 = c_arraySize(c_sequence(src0));
    (*to).length(size0);
    {
        _DDS_IoT_IoTF64 *buf0;
        buf0 = (_DDS_IoT_IoTF64 *)(*to).get_buffer();
        memcpy ((void *)buf0,src0,size0* sizeof(*buf0));
    }
}

void
__DDS_IoT_IoTBSeq__copyOut(
    const void *_from,
    void *_to)
{
    const _DDS_IoT_IoTBSeq *from = (const _DDS_IoT_IoTBSeq *)_from;
    ::DDS::IoT::IoTBSeq *to = (::DDS::IoT::IoTBSeq *)_to;
    long size0;
    const _DDS_IoT_IoTB *src0 = (const _DDS_IoT_IoTB *)(*from);

    size0 = c_arraySize(c_sequence(src0));
    (*to).length(size0);
    {
        _DDS_IoT_IoTB *buf0;
        buf0 = (_DDS_IoT_IoTB *)(*to).get_buffer();
        memcpy ((void *)buf0,src0,size0* sizeof(*buf0));
    }
}

void
__DDS_IoT_IoTStrSeq__copyOut(
    const void *_from,
    void *_to)
{
    const _DDS_IoT_IoTStrSeq *from = (const _DDS_IoT_IoTStrSeq *)_from;
    ::DDS::IoT::IoTStrSeq *to = (::DDS::IoT::IoTStrSeq *)_to;
    long size0;
    const _DDS_IoT_IoTStr *src0 = (const _DDS_IoT_IoTStr *)(*from);

    size0 = c_arraySize(c_sequence(src0));
    (*to).length(size0);
    {
        long i0;
        for (i0 = 0; i0 < size0; i0++) {
            (*to)[i0] = DDS::string_dup(src0[i0] ? src0[i0] : "");
        }
    }
}

void
__DDS_IoT_IoTChSeq__copyOut(
    const void *_from,
    void *_to)
{
    const _DDS_IoT_IoTChSeq *from = (const _DDS_IoT_IoTChSeq *)_from;
    ::DDS::IoT::IoTChSeq *to = (::DDS::IoT::IoTChSeq *)_to;
    long size0;
    const _DDS_IoT_IoTCh *src0 = (const _DDS_IoT_IoTCh *)(*from);

    size0 = c_arraySize(c_sequence(src0));
    (*to).length(size0);
    {
        _DDS_IoT_IoTCh *buf0;
        buf0 = (_DDS_IoT_IoTCh *)(*to).get_buffer();
        memcpy ((void *)buf0,src0,size0* sizeof(*buf0));
    }
}

void
__DDS_IoT_IoTValue__copyOut(
    const void *_from,
    void *_to)
{
    const struct _DDS_IoT_IoTValue *from = (const struct _DDS_IoT_IoTValue *)_from;
    ::DDS::IoT::IoTValue *to = (::DDS::IoT::IoTValue *)_to;
    switch (from->_d) {
    case _DDS_IoT_TYPE_IoTUI8:
        to->ui8((::DDS::Octet)from->_u.ui8);
        break;
    case _DDS_IoT_TYPE_IoTUI16:
        to->ui16((::DDS::UShort)from->_u.ui16);
        break;
    case _DDS_IoT_TYPE_IoTUI32:
        to->ui32((::DDS::ULong)from->_u.ui32);
        break;
    case _DDS_IoT_TYPE_IoTUI64:
        to->ui64((::DDS::ULongLong)from->_u.ui64);
        break;
    case _DDS_IoT_TYPE_IoTI8:
        to->i8((::DDS::Char)from->_u.i8);
        break;
    case _DDS_IoT_TYPE_IoTI16:
        to->i16((::DDS::Short)from->_u.i16);
        break;
    case _DDS_IoT_TYPE_IoTI32:
        to->i32((::DDS::Long)from->_u.i32);
        break;
    case _DDS_IoT_TYPE_IoTI64:
        to->i64((::DDS::LongLong)from->_u.i64);
        break;
    case _DDS_IoT_TYPE_IoTF32:
        to->f32((::DDS::Float)from->_u.f32);
        break;
    case _DDS_IoT_TYPE_IoTF64:
        to->f64((::DDS::Double)from->_u.f64);
        break;
    case _DDS_IoT_TYPE_IoTB:
        to->b((::DDS::Boolean)(from->_u.b != 0));
        break;
    case _DDS_IoT_TYPE_IoTStr:
        to->str(DDS::string_dup(from->_u.str ? from->_u.str : ""));
        break;
    case _DDS_IoT_TYPE_IoTCh:
        to->ch((::DDS::Char)from->_u.ch);
        break;
    case _DDS_IoT_TYPE_IoTUI8Seq:
        {
            extern void __DDS_IoT_IoTUI8Seq__copyOut(const void *, void *);
            ::DDS::IoT::IoTUI8Seq x;            __DDS_IoT_IoTUI8Seq__copyOut((const void *)&from->_u.ui8Seq, (void *)&x);
            to->ui8Seq(x);
        }
        break;
    case _DDS_IoT_TYPE_IoTUI16Seq:
        {
            extern void __DDS_IoT_IoTUI16Seq__copyOut(const void *, void *);
            ::DDS::IoT::IoTUI16Seq x;            __DDS_IoT_IoTUI16Seq__copyOut((const void *)&from->_u.ui16Seq, (void *)&x);
            to->ui16Seq(x);
        }
        break;
    case _DDS_IoT_TYPE_IoTUI32Seq:
        {
            extern void __DDS_IoT_IoTUI32Seq__copyOut(const void *, void *);
            ::DDS::IoT::IoTUI32Seq x;            __DDS_IoT_IoTUI32Seq__copyOut((const void *)&from->_u.ui32Seq, (void *)&x);
            to->ui32Seq(x);
        }
        break;
    case _DDS_IoT_TYPE_IoTUI64Seq:
        {
            extern void __DDS_IoT_IoTUI64Seq__copyOut(const void *, void *);
            ::DDS::IoT::IoTUI64Seq x;            __DDS_IoT_IoTUI64Seq__copyOut((const void *)&from->_u.ui64Seq, (void *)&x);
            to->ui64Seq(x);
        }
        break;
    case _DDS_IoT_TYPE_IoTI8Seq:
        {
            extern void __DDS_IoT_IoTI8Seq__copyOut(const void *, void *);
            ::DDS::IoT::IoTI8Seq x;            __DDS_IoT_IoTI8Seq__copyOut((const void *)&from->_u.i8Seq, (void *)&x);
            to->i8Seq(x);
        }
        break;
    case _DDS_IoT_TYPE_IoTI16Seq:
        {
            extern void __DDS_IoT_IoTI16Seq__copyOut(const void *, void *);
            ::DDS::IoT::IoTI16Seq x;            __DDS_IoT_IoTI16Seq__copyOut((const void *)&from->_u.i16Seq, (void *)&x);
            to->i16Seq(x);
        }
        break;
    case _DDS_IoT_TYPE_IoTI32Seq:
        {
            extern void __DDS_IoT_IoTI32Seq__copyOut(const void *, void *);
            ::DDS::IoT::IoTI32Seq x;            __DDS_IoT_IoTI32Seq__copyOut((const void *)&from->_u.i32Seq, (void *)&x);
            to->i32Seq(x);
        }
        break;
    case _DDS_IoT_TYPE_IoTI64Seq:
        {
            extern void __DDS_IoT_IoTI64Seq__copyOut(const void *, void *);
            ::DDS::IoT::IoTI64Seq x;            __DDS_IoT_IoTI64Seq__copyOut((const void *)&from->_u.i64Seq, (void *)&x);
            to->i64Seq(x);
        }
        break;
    case _DDS_IoT_TYPE_IoTF32Seq:
        {
            extern void __DDS_IoT_IoTF32Seq__copyOut(const void *, void *);
            ::DDS::IoT::IoTF32Seq x;            __DDS_IoT_IoTF32Seq__copyOut((const void *)&from->_u.f32Seq, (void *)&x);
            to->f32Seq(x);
        }
        break;
    case _DDS_IoT_TYPE_IoTF64Seq:
        {
            extern void __DDS_IoT_IoTF64Seq__copyOut(const void *, void *);
            ::DDS::IoT::IoTF64Seq x;            __DDS_IoT_IoTF64Seq__copyOut((const void *)&from->_u.f64Seq, (void *)&x);
            to->f64Seq(x);
        }
        break;
    case _DDS_IoT_TYPE_IoTBSeq:
        {
            extern void __DDS_IoT_IoTBSeq__copyOut(const void *, void *);
            ::DDS::IoT::IoTBSeq x;            __DDS_IoT_IoTBSeq__copyOut((const void *)&from->_u.bSeq, (void *)&x);
            to->bSeq(x);
        }
        break;
    case _DDS_IoT_TYPE_IoTStrSeq:
        {
            extern void __DDS_IoT_IoTStrSeq__copyOut(const void *, void *);
            ::DDS::IoT::IoTStrSeq x;            __DDS_IoT_IoTStrSeq__copyOut((const void *)&from->_u.strSeq, (void *)&x);
            to->strSeq(x);
        }
        break;
    case _DDS_IoT_TYPE_IoTChSeq:
        {
            extern void __DDS_IoT_IoTChSeq__copyOut(const void *, void *);
            ::DDS::IoT::IoTChSeq x;            __DDS_IoT_IoTChSeq__copyOut((const void *)&from->_u.chSeq, (void *)&x);
            to->chSeq(x);
        }
        break;
    }
    to->_d((::DDS::IoT::IoTType)from->_d);
}

void
__DDS_IoT_IoTNVP__copyOut(
    const void *_from,
    void *_to)
{
    const struct _DDS_IoT_IoTNVP *from = (const struct _DDS_IoT_IoTNVP *)_from;
    struct ::DDS::IoT::IoTNVP *to = (struct ::DDS::IoT::IoTNVP *)_to;
    to->name = DDS::string_dup(from->name ? from->name : "");
    {
        extern void __DDS_IoT_IoTValue__copyOut(const void *, void *);
        __DDS_IoT_IoTValue__copyOut((const void *)&from->value, (void *)&to->value);
    }
}

void
__DDS_IoT_IoTNVPSeq__copyOut(
    const void *_from,
    void *_to)
{
    const _DDS_IoT_IoTNVPSeq *from = (const _DDS_IoT_IoTNVPSeq *)_from;
    ::DDS::IoT::IoTNVPSeq *to = (::DDS::IoT::IoTNVPSeq *)_to;
    long size0;
    const struct _DDS_IoT_IoTNVP *src0 = (const struct _DDS_IoT_IoTNVP *)(*from);

    size0 = c_arraySize(c_sequence(src0));
    (*to).length(size0);
    {
        long i0;
        for (i0 = 0; i0 < size0; i0++) {
            extern void __DDS_IoT_IoTNVP__copyOut(const void *from, void *to);
            __DDS_IoT_IoTNVP__copyOut((const void *)&src0[i0], (void *)&(*to)[i0]);
        }
    }
}

void
__DDS_IoT_IoTData__copyOut(
    const void *_from,
    void *_to)
{
    const struct _DDS_IoT_IoTData *from = (const struct _DDS_IoT_IoTData *)_from;
    struct ::DDS::IoT::IoTData *to = (struct ::DDS::IoT::IoTData *)_to;
    to->typeName = DDS::string_dup(from->typeName ? from->typeName : "");
    to->instanceId = DDS::string_dup(from->instanceId ? from->instanceId : "");
    {
        extern void __DDS_IoT_IoTNVPSeq__copyOut(const void *, void *);
        __DDS_IoT_IoTNVPSeq__copyOut((const void *)&from->values, (void *)&to->values);
    }
}

